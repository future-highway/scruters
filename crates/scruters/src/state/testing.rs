pub(crate) use self::{
    active_component::ActiveComponent,
    auto_generated_groups::AutoGeneratedGroup,
    group_name::GroupName,
};
use crate::{
    cargo::CargoTestArgs,
    command::run,
    message::{Message, TestingMessage},
};
use color_eyre::Result;
use core::time::Duration;
use crossterm::event::{KeyCode, KeyEvent};
use ratatui::widgets::ListState;
use serde::{Deserialize, Serialize};
use tokio::{task::JoinHandle, time::sleep};
use tokio_util::sync::CancellationToken;
use tracing::debug;

mod active_component;
mod auto_generated_groups;
mod group_name;

#[allow(clippy::partial_pub_fields)]
#[allow(clippy::unsafe_derive_deserialize)]
#[derive(Debug, Serialize, Deserialize, Default)]
pub(crate) struct TestingState {
    #[serde(skip, default)]
    pub active_component: ActiveComponent,
    #[serde(skip, default)]
    pub groups_component_state: ListState,
    #[serde(skip, default)]
    pub tests_component_state: ListState,
    #[serde(skip, default)]
    pub groups: Vec<AutoGeneratedGroup>,
    #[serde(skip, default)]
    task: Option<(JoinHandle<()>, CancellationToken)>,
}

impl TestingState {
    pub(super) fn handle_key_event(
        &mut self,
        key_event: KeyEvent,
    ) -> Option<Message> {
        #[allow(clippy::wildcard_enum_match_arm)]
        match key_event.code {
            KeyCode::Char('r')
                if self.active_component
                    == ActiveComponent::Groups =>
            {
                return Some(Message::Testing(
                    TestingMessage::RunGroup,
                ));
            }
            _ => {
                debug!(?key_event, "Unhandled key event");
            }
        };

        None
    }

    pub(super) async fn handle_message(
        &mut self,
        message: TestingMessage,
    ) -> Result<Option<Message>> {
        match message {
            TestingMessage::RunGroup => {
                self.cancel_running_task().await;

                let Some(group) = self.selected_group()
                else {
                    debug!(
                        "Attempted to run group, but no group was selected"
                    );

                    return Ok(None);
                };

                let cancellation_token =
                    CancellationToken::new();
                let cancellaiton_token_clone =
                    cancellation_token.clone();

                let command = CargoTestArgs {
                    args: group.cargo_args,
                    ..CargoTestArgs::default()
                }
                .into_command();

                #[allow(
                    clippy::integer_division_remainder_used
                )]
                let join_handle = tokio::spawn(
                    async move {
                        tokio::select! {
                            () = cancellaiton_token_clone.cancelled() => {
                                debug!("Group run was cancelled");
                            }
                            Err(error) = run(command) => {
                                tracing::error!(?error, "Error running group");
                            }
                        }
                    },
                );

                self.task =
                    Some((join_handle, cancellation_token));
            }
        }

        Ok(None)
    }

    async fn cancel_running_task(&mut self) {
        if let Some((task, cancellation_token)) =
            self.task.take()
        {
            if task.is_finished() {
                return;
            }

            cancellation_token.cancel();
            let mut counter = 0_i32;
            while !task.is_finished() {
                sleep(Duration::from_millis(1)).await;

                counter = counter.saturating_add(1);
                if counter > 50_i32 {
                    task.abort();
                }
                if counter > 100_i32 {
                    break;
                }
            }
        }
    }

    fn selected_group(
        &self,
    ) -> Option<&AutoGeneratedGroup> {
        self.groups_component_state
            .selected()
            .and_then(|i| self.groups.get(i))
    }
}
