pub(crate) use self::{
    active_component::{ActiveComponent, OutputSource},
    test_results::TestResults,
};
use super::helpers::default_list_state;
use crate::{
    command::spawn_command,
    message::{Message, TestingMessage},
    state::testing::groups::auto_generated_groups::auto_generated_group_metadata,
};
use alloc::borrow::Cow;
use cargo_metadata::Metadata;
use color_eyre::{eyre::Context as _, Result};
use core::{fmt::Debug, time::Duration};
use crossterm::event::{KeyCode, KeyEvent};
use futures::{
    stream::{self, select},
    StreamExt as _,
};
use groups::{
    auto_generated_groups::{
        auto_generated_group_metadata::TargetKind,
        AutoGeneratedGroup, AutoGeneratedGroupMetadata,
    },
    AnyGroup, Group, GroupKey, GroupName,
    GroupOutputCaptureMode, Groups,
};
use if_chain::if_chain;
use ratatui::widgets::ListState;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use tests::{Test, TestName, TestResult};
use tokio::{
    io::{AsyncBufReadExt, BufReader},
    process::Command,
    sync::{mpsc::UnboundedSender, watch},
    task::JoinHandle,
    time::sleep,
};
use tokio_stream::wrappers::LinesStream;
use tokio_util::sync::CancellationToken;
use tracing::{debug, error};

mod active_component;
pub(crate) mod groups;
pub(crate) mod test_results;
pub(crate) mod tests;

pub(crate) const AUTO_GENERATED_MARKER: &str = "âœ¨";
const TEST_FAILURE_START: &str = "---- ";
const TEST_FAILURE_START_LEN: usize =
    TEST_FAILURE_START.len();
const TEST_FAILURE_END: &str = " stdout ----";
const TEST_FAILURE_END_LEN: usize = TEST_FAILURE_END.len();

#[allow(clippy::partial_pub_fields)]
#[allow(clippy::unsafe_derive_deserialize)]
#[derive(Debug, Serialize, Deserialize)]
pub(crate) struct TestingState {
    #[serde(skip, default)]
    pub active_component: ActiveComponent,
    #[serde(skip, default = "default_list_state")]
    pub groups_component_state: ListState,
    #[serde(skip, default = "default_list_state")]
    pub tests_component_state: ListState,
    #[serde(skip, default)]
    pub output_scroll_position: usize,
    #[serde(default)]
    pub groups: Groups,
    #[serde(skip, default)]
    pub group_results:
        HashMap<GroupKey<'static>, Vec<String>>,
    #[serde(skip, default)]
    pub test_results: TestResults,
    #[serde(skip, default)]
    group_output_capture_mode: GroupOutputCaptureMode,
    #[serde(skip, default)]
    task: Option<(JoinHandle<()>, CancellationToken)>,
}

impl Default for TestingState {
    fn default() -> Self {
        Self {
            active_component: ActiveComponent::Groups,
            groups_component_state: default_list_state(),
            tests_component_state: default_list_state(),
            output_scroll_position: 0,
            groups: Groups::default(),
            group_results: HashMap::default(),
            test_results: TestResults::default(),
            group_output_capture_mode:
                GroupOutputCaptureMode::default(),
            task: None,
        }
    }
}

impl TestingState {
    pub(super) fn init(
        &mut self,
        metadata_rx: watch::Receiver<Metadata>,
        message_tx: UnboundedSender<Message>,
    ) {
        // We want the initial groups even without the tests
        auto_generated_group_metadata::all_from_metadata(
            &metadata_rx.borrow(),
        )
        .into_iter()
        .map(AutoGeneratedGroup::empty_from_metadata)
        .for_each(|group| {
            self.groups
                .push_front(Group::AutoGenerated(group));
        });

        // We need the groups to be sorted for the binary
        // search to work
        self.groups.make_contiguous().sort_unstable();

        // We want to keep the auto generated groups up to
        // date, so we spawn a task to watch for changes
        drop(tokio::spawn(watch_auto_generated_groups(
            metadata_rx,
            message_tx,
        )));
    }

    #[allow(clippy::too_many_lines)]
    pub(super) fn handle_key_event(
        &mut self,
        key_event: KeyEvent,
    ) -> Option<Message> {
        #[allow(clippy::wildcard_enum_match_arm)]
        match key_event.code {
            KeyCode::Char('1')
                if !matches!(
                    self.active_component,
                    ActiveComponent::Groups,
                ) =>
            {
                Some(Message::Testing(
                    TestingMessage::SetActiveComponent(
                        ActiveComponent::Groups,
                    ),
                ))
            }
            KeyCode::Char('2')
                if !matches!(
                    self.active_component,
                    ActiveComponent::Tests,
                ) =>
            {
                Some(Message::Testing(
                    TestingMessage::SetActiveComponent(
                        ActiveComponent::Tests,
                    ),
                ))
            }
            KeyCode::Char('3')
                if !matches!(
                    self.active_component,
                    ActiveComponent::Output(_)
                ) =>
            {
                let output_source = match self
                    .active_component
                {
                    ActiveComponent::Groups => {
                        OutputSource::Groups
                    }
                    ActiveComponent::Tests => {
                        OutputSource::Tests
                    }
                    ActiveComponent::Output(_) => {
                        unreachable!(
                            "match guard should prevent this"
                        )
                    }
                };

                Some(Message::Testing(
                    TestingMessage::SetActiveComponent(
                        ActiveComponent::Output(
                            output_source,
                        ),
                    ),
                ))
            }
            KeyCode::Char('r')
                if self.active_component
                    == ActiveComponent::Groups =>
            {
                Some(Message::Testing(
                    TestingMessage::RunSelectedGroup,
                ))
            }
            KeyCode::Char('r')
                if self.active_component
                    == ActiveComponent::Tests =>
            {
                Some(Message::Testing(
                    TestingMessage::RunSelectedTest,
                ))
            }
            KeyCode::Char('r')
                if self.active_component
                    == ActiveComponent::Output(
                        OutputSource::Groups,
                    ) =>
            {
                Some(Message::Testing(
                    TestingMessage::RunSelectedGroup,
                ))
            }
            KeyCode::Char('r')
                if self.active_component
                    == ActiveComponent::Output(
                        OutputSource::Tests,
                    ) =>
            {
                Some(Message::Testing(
                    TestingMessage::RunSelectedTest,
                ))
            }
            KeyCode::Down
                if self.active_component
                    == ActiveComponent::Groups =>
            {
                Some(Message::Testing(
                    TestingMessage::SelectNextGroup,
                ))
            }
            KeyCode::Down
                if self.active_component
                    == ActiveComponent::Tests =>
            {
                Some(Message::Testing(
                    TestingMessage::SelectNextTest,
                ))
            }
            KeyCode::Esc
                if self.active_component
                    == ActiveComponent::Tests =>
            {
                Some(Message::Testing(
                    TestingMessage::SetActiveComponent(
                        ActiveComponent::Groups,
                    ),
                ))
            }
            KeyCode::End
                if self.active_component
                    == ActiveComponent::Groups =>
            {
                Some(Message::Testing(
                    TestingMessage::SelectLastGroup,
                ))
            }
            KeyCode::End
                if self.active_component
                    == ActiveComponent::Tests =>
            {
                Some(Message::Testing(
                    TestingMessage::SelectLastTest,
                ))
            }
            KeyCode::Enter
                if self.active_component
                    == ActiveComponent::Groups =>
            {
                Some(Message::Testing(
                    TestingMessage::SetActiveComponent(
                        ActiveComponent::Tests,
                    ),
                ))
            }
            KeyCode::Home
                if self.active_component
                    == ActiveComponent::Groups =>
            {
                Some(Message::Testing(
                    TestingMessage::SelectFirstGroup,
                ))
            }
            KeyCode::Home
                if self.active_component
                    == ActiveComponent::Tests =>
            {
                Some(Message::Testing(
                    TestingMessage::SelectFirstTest,
                ))
            }
            KeyCode::Up
                if self.active_component
                    == ActiveComponent::Groups =>
            {
                Some(Message::Testing(
                    TestingMessage::SelectPreviousGroup,
                ))
            }
            KeyCode::Up
                if self.active_component
                    == ActiveComponent::Tests =>
            {
                Some(Message::Testing(
                    TestingMessage::SelectPreviousTest,
                ))
            }
            _ => None,
        }
    }

    #[allow(clippy::too_many_lines)]
    pub(super) async fn handle_message(
        &mut self,
        message: TestingMessage,
        message_tx: UnboundedSender<Message>,
    ) -> Result<Option<Message>> {
        match message {
            TestingMessage::OutputFromGroupRun(
                group_key,
                line,
            ) => {
                let capture_mode =
                    &mut self.group_output_capture_mode;

                if line.starts_with(TEST_FAILURE_START)
                    && line.ends_with(TEST_FAILURE_END)
                {
                    let test_name = TestName(
                        line.chars()
                            .skip(TEST_FAILURE_START_LEN)
                            .take(
                                line.len()
                                    .saturating_sub(TEST_FAILURE_START_LEN)
                                    .saturating_sub(TEST_FAILURE_END_LEN)
                            )
                            .collect::<String>(),
                    );

                    *capture_mode =
                        GroupOutputCaptureMode::FailedTest(
                            Test::Named(test_name),
                        );
                }

                if_chain! {
                    if let GroupOutputCaptureMode::Normal = capture_mode;
                    if line.starts_with("test ");
                    let mut parts = line.split(' ');
                    let test_name = parts.nth(1);
                    if let Some(test_name) = test_name;
                    let test_name = TestName(test_name.to_owned());
                    if let Some("...") = parts.next();
                    let result = parts.next();
                    if let Some(result) = result;
                    if parts.next().is_none();
                    then {
                        let passed = result.contains("ok");

                        let test_result = self.test_results
                            .as_inner_mut()
                            .entry(Test::Named(test_name))
                            .and_modify(|test_result| {
                                test_result.passed = Some(passed);
                                test_result.output.clear();
                            })
                            .or_insert_with(|| {
                                TestResult {
                                    passed: Some(passed),
                                    output: Vec::new(),
                                }
                            });

                        test_result
                            .output
                            .push(line.clone());
                    }
                }

                if let GroupOutputCaptureMode::FailedTest(
                    test,
                ) = capture_mode
                {
                    if let Some(test_result) = self
                        .test_results
                        .as_inner_mut()
                        .get_mut(test)
                    {
                        test_result
                            .output
                            .push(line.clone());
                    }
                }

                let group_result = self
                    .group_results
                    .entry(group_key)
                    .or_default();

                group_result.push(line);
            }
            TestingMessage::OutputFromTestRun(
                test,
                line,
            ) => {
                let return_message =
                    if let Test::IntegrationTarget {
                        package_name,
                        target_name,
                    } = &test
                    {
                        let group_key = GroupKey::AutoGenerated(Cow::Owned(AutoGeneratedGroupMetadata {
                                package_name: package_name.to_owned(),
                                target_kind:
                                    TargetKind::Test(
                                        target_name
                                            .to_owned(),
                                    ),
                            }));

                        Some(Message::Testing(TestingMessage::OutputFromGroupRun(group_key, line.clone())))
                    } else {
                        None
                    };

                let test_result = self
                    .test_results
                    .as_inner_mut()
                    .entry(test)
                    .or_insert_with(|| {
                        TestResult::default()
                    });

                if_chain! {
                    if line.starts_with("test ");
                    let mut parts = line.split(' ');
                    let output_test_name = parts.nth(1);
                    if output_test_name.is_some();
                    if let Some("...") = parts.next();
                    let result = parts.next();
                    if let Some(result) = result;
                    if parts.next().is_none();
                    then {
                        test_result.passed = Some(result.contains("ok"));
                    }
                }

                // TODO: Clear output when test is re-run on
                // watch mode

                test_result.output.push(line);
                return Ok(return_message);
            }
            TestingMessage::RetainAutoGeneratedGroups(
                group_names,
            ) => {
                self.groups.retain(|group| match group {
                    Group::Custom(_) => true,
                    Group::AutoGenerated(group) => {
                        group_names.contains(&group.name())
                    }
                });
            }
            TestingMessage::RunSelectedGroup => {
                self.cancel_running_task().await;

                let Some(group) = self
                    .groups_component_state
                    .selected()
                    .and_then(|index| {
                        self.groups.get(index)
                    })
                else {
                    debug!(
                        "Attempted to run group, but no group was selected"
                    );

                    return Ok(None);
                };

                let group_key =
                    group.as_group_key().clone();

                drop(
                    self.group_results
                        .remove_entry(&group_key),
                );

                self.output_scroll_position = 0;

                self.group_output_capture_mode =
                    GroupOutputCaptureMode::default();

                self.task = Some(
                    run_group(group, message_tx)
                        .wrap_err("Failed to run group")?,
                );
            }
            TestingMessage::RunSelectedTest => {
                self.cancel_running_task().await;

                let Some(group) = self
                    .groups_component_state
                    .selected()
                    .and_then(|index| {
                        self.groups.get(index)
                    })
                else {
                    debug!(
                        "Attempted to run test, but no group was selected"
                    );

                    return Ok(None);
                };

                let Some(test) = self
                    .tests_component_state
                    .selected()
                    .and_then(|index| {
                        group.tests().get(index)
                    })
                    .cloned()
                else {
                    debug!(
                        "Attempted to run test, but no test was selected"
                    );

                    return Ok(None);
                };

                if let Some(test_result) = self
                    .test_results
                    .as_inner_mut()
                    .get_mut(&test)
                {
                    test_result.reset();
                }

                self.output_scroll_position = 0;

                self.task = Some(
                    run_test(test, message_tx)
                        .wrap_err("Failed to run test")?,
                );
            }
            TestingMessage::SetActiveComponent(
                component,
            ) => {
                self.active_component = component;
            }
            TestingMessage::SelectFirstGroup => {
                self.groups_component_state.select_first();
            }
            TestingMessage::SelectFirstTest => {
                self.tests_component_state.select_first();
            }
            TestingMessage::SelectLastGroup => {
                self.groups_component_state.select_last();
            }
            TestingMessage::SelectLastTest => {
                self.tests_component_state.select_last();
            }
            TestingMessage::SelectNextGroup => {
                self.groups_component_state.select_next();
            }
            TestingMessage::SelectNextTest => {
                self.tests_component_state.select_next();
            }
            TestingMessage::SelectPreviousGroup => {
                self.groups_component_state
                    .select_previous();
            }
            TestingMessage::SelectPreviousTest => {
                self.tests_component_state
                    .select_previous();
            }
            TestingMessage::UpsertGroup(group) => {
                match self.groups.binary_search(&group) {
                    Ok(index) => {
                        let Some(existing_group) =
                            self.groups.get_mut(index)
                        else {
                            unreachable!(
                                "Group index not found following successful binary search"
                            );
                        };

                        existing_group.update_group(group);
                    }
                    Err(i) => {
                        self.groups.insert(i, group);
                    }
                }

                if self
                    .tests_component_state
                    .selected()
                    .is_none()
                {
                    self.tests_component_state
                        .select_first();
                }
            }
        }

        Ok(None)
    }

    async fn cancel_running_task(&mut self) {
        if let Some((task, cancellation_token)) =
            self.task.take()
        {
            if task.is_finished() {
                return;
            }

            cancellation_token.cancel();
            let mut counter = 0_i32;
            while !task.is_finished() {
                sleep(Duration::from_millis(1)).await;

                counter = counter.saturating_add(1);
                if counter > 50_i32 {
                    task.abort();
                }
                if counter > 100_i32 {
                    break;
                }
            }
        }
    }

    pub fn get_group_status<Group: AnyGroup>(
        &self,
        group: &Group,
    ) -> Option<bool> {
        let mut status = Some(true);

        for test in group.tests() {
            match self.get_test_status(test) {
                None if matches!(status, Some(true)) => {
                    status = None;
                }
                Some(false) => {
                    status = Some(false);
                    break;
                }
                Some(true) | None => {}
            }
        }

        status
    }

    pub fn get_test_status(
        &self,
        test: &Test,
    ) -> Option<bool> {
        if let Test::IntegrationTarget {
            package_name,
            target_name,
        } = &test
        {
            let target_group = Group::AutoGenerated(
                AutoGeneratedGroup::empty_from_metadata(
                    AutoGeneratedGroupMetadata {
                        package_name: package_name
                            .to_owned(),
                        target_kind: TargetKind::Test(
                            target_name.to_owned(),
                        ),
                    },
                ),
            );

            let group = self
                .groups
                .binary_search(&target_group)
                .ok()
                .and_then(|index| self.groups.get(index))?;

            return self.get_group_status(group);
        }

        self.test_results
            .as_inner()
            .get(test)
            .and_then(|test_result| test_result.passed)
    }

    pub fn get_group_output<'a, Group: AnyGroup>(
        &'a self,
        group: &'a Group,
    ) -> Option<&'a [String]> {
        let group_key = group.as_group_key();

        self.group_results
            .get(&group_key)
            .map(AsRef::as_ref)
    }

    pub fn get_test_output<'a>(
        &'a self,
        test: &'a Test,
    ) -> Option<&'a [String]> {
        if let Test::IntegrationTarget {
            package_name,
            target_name,
        } = &test
        {
            let target_group = Group::AutoGenerated(
                AutoGeneratedGroup::empty_from_metadata(
                    AutoGeneratedGroupMetadata {
                        package_name: package_name
                            .to_owned(),
                        target_kind: TargetKind::Test(
                            target_name.to_owned(),
                        ),
                    },
                ),
            );

            let group = self
                .groups
                .binary_search(&target_group)
                .ok()
                .and_then(|index| self.groups.get(index))?;

            return self.get_group_output(group);
        }

        self.test_results
            .as_inner()
            .get(test)
            .map(|test_result| &*test_result.output)
    }
}

async fn watch_auto_generated_groups(
    mut metadata_rx: watch::Receiver<Metadata>,
    message_tx: UnboundedSender<Message>,
) {
    loop {
        debug!(
            "Metadata changed...updating auto generated groups"
        );

        let metadata = {
            auto_generated_group_metadata::all_from_metadata(
                &metadata_rx.borrow_and_update(),
            )
        };

        let names_to_retain =
            metadata.iter().map(GroupName::from).collect();

        if let Err(error) =
            message_tx.send(Message::Testing(
                TestingMessage::RetainAutoGeneratedGroups(
                    names_to_retain,
                ),
            ))
        {
            error!(
                ?error,
                "Error sending message to retain auto generated groups"
            );

            return;
        }

        let cancellation_token = CancellationToken::new();
        let cancellation_token_clone =
            cancellation_token.clone();
        let tx = message_tx.clone();

        #[allow(clippy::integer_division_remainder_used)]
        drop(tokio::spawn(async move {
            tokio::select! {
                () = cancellation_token_clone.cancelled() => {
                    debug!("Cancelling auto generated group creation");
                }
                () = stream::iter(metadata)
                    .for_each(|metadata| async {
                        match AutoGeneratedGroup::from_metadata(
                            metadata,
                            cancellation_token_clone.clone(),
                        )
                        .await {
                            Ok(Some(group)) => {
                                if let Err(error) = tx.send(Message::Testing(
                                    TestingMessage::UpsertGroup(group.into()),
                                )) {
                                    error!(
                                        ?error,
                                        "Error sending auto generated group"
                                    );
                                }
                            }
                            Ok(None) => {}
                            Err(error) => {
                                error!(?error, "Error creating auto generated group");
                            }
                        }
                    }) => {}
            }
        }));

        match metadata_rx.changed().await {
            Ok(()) => {
                cancellation_token.cancel();
            }
            Err(_) => break,
        }
    }
}

fn run_group<Group: AnyGroup>(
    group: &Group,
    messages_tx: UnboundedSender<Message>,
) -> Result<(JoinHandle<()>, CancellationToken)> {
    let command = group.to_cargo_test_args().into_command();
    let group_key = group.as_group_key().clone();
    run_command(command, messages_tx, move |line| {
        TestingMessage::OutputFromGroupRun(
            group_key.clone(),
            line,
        )
    })
}

fn run_test(
    test: Test,
    messages_tx: UnboundedSender<Message>,
) -> Result<(JoinHandle<()>, CancellationToken)> {
    let command = test.to_cargo_test_args().into_command();
    run_command(command, messages_tx, move |line| {
        TestingMessage::OutputFromTestRun(
            test.clone(),
            line,
        )
    })
}

fn run_command(
    command: Command,
    messages_tx: UnboundedSender<Message>,
    f: impl Fn(String) -> TestingMessage + Send + 'static,
) -> Result<(JoinHandle<()>, CancellationToken)> {
    let cancellation_token = CancellationToken::new();

    let (stdout, stderr) =
        spawn_command(command, cancellation_token.clone())
            .wrap_err("Failed to spawn command")?;

    let mut reader = select(
        LinesStream::new(BufReader::new(stdout).lines()),
        LinesStream::new(BufReader::new(stderr).lines()),
    );

    let join_handle = tokio::spawn(async move {
        while let Ok(Some(line)) = reader
            .next()
            .await
            .transpose()
            .map_err(|error| {
                tracing::error!(
                    ?error,
                    "Error reading line from command output"
                );
            })
        {
            let message = f(line);
            if let Err(error) =
                messages_tx.send(Message::Testing(message))
            {
                tracing::error!(
                    ?error,
                    "Failed to send run output message"
                );
            }
        }
    });

    Ok((join_handle, cancellation_token))
}
