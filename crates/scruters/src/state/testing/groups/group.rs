use super::{
    AnyGroup, AutoGeneratedGroup, CustomGroup, GroupName,
};
use crate::{
    cargo::CargoTestArgs, state::testing::tests::Test,
};
use alloc::borrow::Cow;
use core::cmp::Ordering;
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub enum Group {
    #[serde(skip)]
    AutoGenerated(AutoGeneratedGroup),
    Custom(CustomGroup),
}

impl Group {
    pub const fn should_serialize(&self) -> bool {
        !matches!(self, Self::AutoGenerated(_))
    }
}

impl From<AutoGeneratedGroup> for Group {
    fn from(group: AutoGeneratedGroup) -> Self {
        Self::AutoGenerated(group)
    }
}

impl From<CustomGroup> for Group {
    fn from(group: CustomGroup) -> Self {
        Self::Custom(group)
    }
}

impl AnyGroup for Group {
    fn name(&self) -> Cow<'_, GroupName> {
        match self {
            Self::AutoGenerated(group) => group.name(),
            Self::Custom(group) => group.name(),
        }
    }

    fn tests(&self) -> &[Test] {
        match self {
            Self::AutoGenerated(group) => group.tests(),
            Self::Custom(group) => group.tests(),
        }
    }

    fn update_group(&mut self, group: Group) {
        match self {
            Self::AutoGenerated(g) => {
                g.update_group(group);
            }
            Self::Custom(g) => g.update_group(group),
        }
    }

    fn to_cargo_test_args(&self) -> CargoTestArgs<'_> {
        match self {
            Self::AutoGenerated(group) => {
                group.to_cargo_test_args()
            }
            Self::Custom(group) => {
                group.to_cargo_test_args()
            }
        }
    }

    fn push_output(&mut self, line: String) {
        match self {
            Self::AutoGenerated(group) => {
                group.push_output(line);
            }
            Self::Custom(group) => group.push_output(line),
        }
    }

    fn output(&self) -> Option<&[String]> {
        match self {
            Self::AutoGenerated(group) => group.output(),
            Self::Custom(group) => group.output(),
        }
    }
}

#[allow(clippy::missing_trait_methods)]
impl PartialEq for Group {
    fn eq(&self, other: &Self) -> bool {
        self.name() == other.name()
    }
}

#[allow(clippy::missing_trait_methods)]
impl Eq for Group {}

#[allow(clippy::missing_trait_methods)]
impl PartialOrd for Group {
    fn partial_cmp(
        &self,
        other: &Self,
    ) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

#[allow(clippy::missing_trait_methods)]
impl Ord for Group {
    fn cmp(&self, other: &Self) -> Ordering {
        self.name().cmp(&other.name())
    }
}
