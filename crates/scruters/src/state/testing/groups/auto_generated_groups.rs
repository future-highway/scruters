pub(crate) use self::auto_generated_group_metadata::AutoGeneratedGroupMetadata;
use super::{AnyGroup, GroupName};
use crate::{
    cargo::CargoTestArgs, command::spawn_command,
    state::testing::TestName,
};
use alloc::borrow::Cow;
use color_eyre::{eyre::Context, Result};
use core::cmp::Ordering;
use futures::stream::select;
use if_chain::if_chain;
use tokio::io::{AsyncBufReadExt as _, BufReader};
use tokio_stream::{wrappers::LinesStream, StreamExt};
use tokio_util::sync::CancellationToken;

pub mod auto_generated_group_metadata;

#[derive(Debug)]
pub(crate) struct AutoGeneratedGroup {
    name: GroupName,
    metadata: AutoGeneratedGroupMetadata,
    pub(super) tests: Vec<TestName>,
    output: Option<Vec<String>>,
}

impl AutoGeneratedGroup {
    pub(in crate::state::testing) fn empty_from_metadata(
        metadata: AutoGeneratedGroupMetadata,
    ) -> Self {
        Self {
            name: GroupName::from(&metadata),
            metadata,
            tests: Vec::new(),
            output: None,
        }
    }
    pub(in crate::state::testing) async fn from_metadata(
        metadata: AutoGeneratedGroupMetadata,
        cancellation_token: CancellationToken,
    ) -> Result<Option<Self>> {
        const TEST_LINE_SUFFIX: &str = ": test";
        const TEST_LINE_SUFFIX_LEN: usize =
            TEST_LINE_SUFFIX.len();

        let command = CargoTestArgs {
            args: metadata.to_args().map(Into::into),
            color: false,
            list: true,
            ..Default::default()
        }
        .into_command();

        let (stdout, stderr) = spawn_command(
            command,
            cancellation_token.clone(),
        )
        .wrap_err("Failed to run command listing tests")?;

        let mut reader = select(
            LinesStream::new(
                BufReader::new(stdout).lines(),
            ),
            LinesStream::new(
                BufReader::new(stderr).lines(),
            ),
        );

        let mut test_names = Vec::new();

        #[allow(clippy::integer_division_remainder_used)]
        loop {
            tokio::select! {
                () = cancellation_token.cancelled() => {
                    return Ok(None);
                }
                maybe_line = reader.next() => match maybe_line.transpose().context("Failed to read line from command output")? {
                    Some(mut line) =>{
                        if_chain! {
                            if line.ends_with(TEST_LINE_SUFFIX);
                            let _ = line.split_off(line.len().saturating_sub(TEST_LINE_SUFFIX_LEN));
                            if !line.is_empty() && !line.contains(' ');
                            then {
                                test_names.push(line);
                            }
                        }
                    }
                    None => {
                        return Ok(Some(Self {
                            name: GroupName::from(&metadata),
                            metadata,
                            tests: test_names.into_iter().map(TestName).collect(),
                            output: None,
                        }))
                    }
                }
            }
        }
    }
}

impl AnyGroup for AutoGeneratedGroup {
    fn name(&self) -> Cow<'_, GroupName> {
        Cow::Borrowed(&self.name)
    }

    fn tests(&self) -> &[TestName] {
        &self.tests
    }

    fn set_tests(&mut self, tests: Vec<TestName>) {
        self.tests = tests;
    }

    fn to_cargo_test_args(&self) -> CargoTestArgs<'_> {
        let args = self.metadata.to_args().map(Into::into);
        CargoTestArgs { args, ..CargoTestArgs::default() }
    }

    fn push_output(&mut self, line: String) {
        if let Some(output) = &mut self.output {
            output.push(line);
        } else {
            self.output = Some(vec![line]);
        }
    }
}

#[allow(clippy::missing_trait_methods)]
impl PartialEq for AutoGeneratedGroup {
    fn eq(&self, other: &Self) -> bool {
        self.metadata == other.metadata
    }
}

#[allow(clippy::missing_trait_methods)]
impl Eq for AutoGeneratedGroup {}

#[allow(clippy::missing_trait_methods)]
impl PartialOrd for AutoGeneratedGroup {
    fn partial_cmp(
        &self,
        other: &Self,
    ) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

#[allow(clippy::missing_trait_methods)]
impl Ord for AutoGeneratedGroup {
    fn cmp(&self, other: &Self) -> Ordering {
        self.metadata.cmp(&other.metadata)
    }
}
