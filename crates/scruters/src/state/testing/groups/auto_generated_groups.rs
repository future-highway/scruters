use super::GroupName;
use crate::{
    cargo::CargoTestArgs,
    command::spawn_command,
    message::{Message, TestingMessage},
    state::testing::TestName,
};
use color_eyre::{eyre::Context, Result};
use futures::stream::select;
use if_chain::if_chain;
use std::mem::swap;
use tokio::{
    io::{AsyncBufReadExt as _, BufReader},
    sync::mpsc::UnboundedSender,
    task::JoinHandle,
};
use tokio_stream::{wrappers::LinesStream, StreamExt};
use tokio_util::sync::CancellationToken;
use tracing::error;

#[derive(Debug)]
pub(crate) struct AutoGeneratedGroup {
    pub(super) cargo_args: Option<&'static [&'static str]>,
    pub(crate) tests: Option<Vec<TestName>>,
    watch_task: Option<(JoinHandle<()>, CancellationToken)>,
}

impl AutoGeneratedGroup {
    fn new(
        group_name: GroupName,
        cargo_args: Option<&'static [&'static str]>,
        message_tx: UnboundedSender<Message>,
    ) -> Result<Self> {
        let cancellation_token = CancellationToken::new();
        let cancellation_token_clone =
            cancellation_token.clone();

        let watch_task = tokio::spawn(async move {
            if let Err(error) = watch_for_test_names(
                group_name,
                cargo_args,
                message_tx,
                cancellation_token_clone,
            )
            .await
            {
                error!(
                    ?error,
                    "Failed to watch for test names"
                );
            }
        });

        Ok(Self {
            cargo_args,
            tests: None,
            watch_task: Some((
                watch_task,
                cancellation_token,
            )),
        })
    }
}

async fn watch_for_test_names(
    group_name: GroupName,
    cargo_args: Option<&'static [&'static str]>,
    message_tx: UnboundedSender<Message>,
    cancellation_token: CancellationToken,
) -> Result<()> {
    let command = CargoTestArgs {
        args: cargo_args,
        color: false,
        list: true,
        ..Default::default()
    }
    .into_command();

    let (stdout, stderr) =
        spawn_command(command, cancellation_token)
            .wrap_err(
                "Failed to run command listing tests",
            )?;

    let mut reader = select(
        LinesStream::new(BufReader::new(stdout).lines()),
        LinesStream::new(BufReader::new(stderr).lines()),
    );

    const TEST_LINE_SUFFIX: &str = ": test";
    const TEST_LINE_SUFFIX_LEN: usize =
        TEST_LINE_SUFFIX.len();

    let mut test_names = Vec::new();

    while let Some(mut line) =
        reader.next().await.transpose().expect(
            "failed to read line from cargo test output",
        )
    {
        if_chain! {
            if line.ends_with(TEST_LINE_SUFFIX);
            let _ = line.split_off(line.len() - TEST_LINE_SUFFIX_LEN);
            if !line.contains(' ');
            then {
                test_names.push(line);
                continue;
            }
        }

        if line
            .starts_with("[Finished running. Exit status: ")
        {
            let mut old_test_names = vec![];
            swap(&mut old_test_names, &mut test_names);

            let tests = old_test_names
                .into_iter()
                .map(TestName)
                .collect::<Vec<_>>();

            if let Err(error) =
                message_tx.send(Message::Testing(
                    TestingMessage::ReplaceGroupTests(
                        group_name.clone(),
                        tests,
                    ),
                ))
            {
                error!(
                    ?error,
                    "Failed to send replace group tests message"
                );
            }

            continue;
        }
    }

    Ok(())
}
