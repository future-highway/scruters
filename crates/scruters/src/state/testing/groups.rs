pub(crate) use self::{
    auto_generated_groups::AutoGeneratedGroup,
    custom_groups::CustomGroup, group_name::GroupName,
};
use super::TestName;
use crate::{
    cargo::CargoTestArgs,
    command::spawn_command,
    message::{Message, TestingMessage},
};
use color_eyre::eyre::{Context, Result};
use futures::stream::select;
use serde::{Deserialize, Serialize};
use tokio::{
    io::{AsyncBufReadExt as _, BufReader},
    sync::mpsc::UnboundedSender,
    task::JoinHandle,
};
use tokio_stream::{wrappers::LinesStream, StreamExt};
use tokio_util::sync::CancellationToken;

mod auto_generated_groups;
mod custom_groups;
mod group_name;

#[derive(Debug, Serialize, Deserialize)]
pub(crate) enum GroupKind {
    #[serde(skip)]
    AutoGenerated(AutoGeneratedGroup),
    Custom(CustomGroup),
}

#[derive(Debug, Serialize, Deserialize)]
pub(crate) struct Group {
    pub(crate) name: GroupName,
    kind: GroupKind,
    #[serde(skip, default)]
    output: Option<Vec<String>>,
}

impl Group {
    pub(crate) fn to_cargo_test_args(
        &self,
    ) -> CargoTestArgs<'_> {
        match &self.kind {
            GroupKind::AutoGenerated(group) => {
                CargoTestArgs {
                    args: group.cargo_args,
                    ..CargoTestArgs::default()
                }
            }
            GroupKind::Custom(_) => {
                todo!(
                    "Implement custom group to cargo test args"
                )
            }
        }
    }

    pub(super) fn replace_tests(
        &mut self,
        tests: Vec<TestName>,
    ) {
        match &mut self.kind {
            GroupKind::AutoGenerated(group) => {
                group.tests = Some(tests);
            }
            GroupKind::Custom(_) => {
                todo!(
                    "Implement custom group replace tests"
                )
            }
        }
    }

    pub(super) fn push_output(&mut self, line: String) {
        if let Some(output) = &mut self.output {
            output.push(line);
        } else {
            self.output = Some(vec![line]);
        }
    }
}

pub(super) fn run_group(
    group: &Group,
    messages_tx: UnboundedSender<Message>,
) -> Result<(JoinHandle<()>, CancellationToken)> {
    let cancellation_token = CancellationToken::new();

    let command = group.to_cargo_test_args().into_command();

    let (stdout, stderr) =
        spawn_command(command, cancellation_token.clone())
            .wrap_err("Failed to spawn command")?;

    let mut reader = select(
        LinesStream::new(BufReader::new(stdout).lines()),
        LinesStream::new(BufReader::new(stderr).lines()),
    );

    let group_name = group.name.clone();

    let join_handle = tokio::spawn(async move {
        while let Ok(Some(line)) =
            reader.next().await.transpose().map_err(|error| {
                tracing::error!(
                    ?error,
                    "Error reading line from run group command output"
                );
            })
        {
            if let Err(error) = messages_tx.send(Message::Testing(TestingMessage::GroupRunOutput(group_name.clone(), line))) {
                tracing::error!(
                    ?error,
                    "Failed to send group run output message"
                );
            }
        }
    });

    Ok((join_handle, cancellation_token))
}
