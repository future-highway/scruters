use self::{
    auto_generated_groups::{
        AutoGeneratedGroup, AutoGeneratedGroupMetadata,
    },
    custom_groups::CustomGroup,
};
pub(crate) use self::{
    group::Group, group_key::GroupKey,
    group_name::GroupName,
    group_output::GroupOutputCaptureMode,
};
use super::tests::Test;
use crate::cargo::CargoTestArgs;
use alloc::{borrow::Cow, collections::VecDeque};
use color_eyre::eyre::Result;
use core::ops::{Deref, DerefMut};
use serde::{Deserialize, Serialize};

pub mod auto_generated_groups;
mod custom_groups;
mod group;
mod group_key;
mod group_name;
mod group_output;

pub(crate) trait AnyGroup {
    fn name(&self) -> Cow<'_, GroupName>;

    fn tests(&self) -> &[Test];

    fn update_group(&mut self, group: Group);

    fn to_cargo_test_args(&self) -> CargoTestArgs<'_>;

    fn as_group_key(&self) -> GroupKey<'_>;
}

#[derive(Debug, Default)]
pub(crate) struct Groups(VecDeque<Group>);

impl Serialize for Groups {
    fn serialize<S>(
        &self,
        serializer: S,
    ) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let filtered: Vec<&Group> = self
            .0
            .iter()
            .filter(|group| group.should_serialize())
            .collect();

        filtered.serialize(serializer)
    }
}

#[allow(clippy::missing_trait_methods)]
impl<'de> Deserialize<'de> for Groups {
    fn deserialize<D>(
        deserializer: D,
    ) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let groups: VecDeque<Group> =
            VecDeque::deserialize(deserializer)?;

        Ok(Self(groups))
    }
}

impl Deref for Groups {
    type Target = VecDeque<Group>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for Groups {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
